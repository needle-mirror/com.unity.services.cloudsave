//-----------------------------------------------------------------------------
// <auto-generated>
//     This file was generated by the C# SDK Code Generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//-----------------------------------------------------------------------------


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using UnityEngine;
using UnityEngine.Networking;
using UnityEngine.Scripting;
using Unity.Services.CloudSave.Internal.Models;
using Unity.Services.CloudSave.Internal.Scheduler;
using Unity.Services.CloudSave.Internal.Http;
using Unity.Services.Authentication.Internal;

namespace Unity.Services.CloudSave.Internal.Data
{
    internal static class JsonSerialization
    {
        public static byte[] Serialize<T>(T obj)
        {
            return Encoding.UTF8.GetBytes(SerializeToString(obj));
        }

        public static string SerializeToString<T>(T obj)
        {
            return IsolatedJsonConvert.SerializeObject(obj,
                new JsonSerializerSettings { ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore });
        }
    }

    /// <summary>
    /// DataApiBaseRequest class
    /// </summary>
    [Preserve]
    internal class DataApiBaseRequest
    {
        /// <summary>
        /// Helper function to add a provided key and value to the provided
        /// query params and to escape the values correctly if it is a URL.
        /// </summary>
        /// <param name="queryParams">A `List/<string/>` of the query parameters.</param>
        /// <param name="key">The key to be added.</param>
        /// <param name="value">The value to be added.</param>
        /// <returns>Returns a `List/<string/>` with the `key` and `value` added to the provided `queryParams`.</returns>
        [Preserve]
        public List<string> AddParamsToQueryParams(List<string> queryParams, string key, string value)
        {
            key = UnityWebRequest.EscapeURL(key);
            value = UnityWebRequest.EscapeURL(value);
            queryParams.Add($"{key}={value}");

            return queryParams;
        }

        /// <summary>
        /// Helper function to add a provided key and list of values to the
        /// provided query params and to escape the values correctly if it is a
        /// URL.
        /// </summary>
        /// <param name="queryParams">A `List/<string/>` of the query parameters.</param>
        /// <param name="key">The key to be added.</param>
        /// <param name="values">List of values to be added.</param>
        /// <param name="style">string for defining the style, currently unused.</param>
        /// <param name="explode">True if query params should be escaped and added separately.</param>
        /// <returns>Returns a `List/<string/>`</returns>
        [Preserve]
        public List<string> AddParamsToQueryParams(List<string> queryParams, string key, List<string> values,
            string style, bool explode)
        {
            if (explode)
            {
                foreach (var value in values)
                {
                    string escapedValue = UnityWebRequest.EscapeURL(value);
                    queryParams.Add($"{UnityWebRequest.EscapeURL(key)}={escapedValue}");
                }
            }
            else
            {
                string paramString = $"{UnityWebRequest.EscapeURL(key)}=";
                foreach (var value in values)
                {
                    paramString += UnityWebRequest.EscapeURL(value) + ",";
                }

                paramString = paramString.Remove(paramString.Length - 1);
                queryParams.Add(paramString);
            }

            return queryParams;
        }

        /// <summary>
        /// Helper function to add a provided map of keys and values, representing a model, to the
        /// provided query params.
        /// </summary>
        /// <param name="queryParams">A `List/<string/>` of the query parameters.</param>
        /// <param name="modelVars">A `Dictionary` representing the vars of the model</param>
        /// <returns>Returns a `List/<string/>`</returns>
        [Preserve]
        public List<string> AddParamsToQueryParams(List<string> queryParams, Dictionary<string, string> modelVars)
        {
            foreach (var key in modelVars.Keys)
            {
                string escapedValue = UnityWebRequest.EscapeURL(modelVars[key]);
                queryParams.Add($"{UnityWebRequest.EscapeURL(key)}={escapedValue}");
            }

            return queryParams;
        }

        /// <summary>
        /// Helper function to add a provided key and value to the provided
        /// query params and to escape the values correctly if it is a URL.
        /// </summary>
        /// <param name="queryParams">A `List/<string/>` of the query parameters.</param>
        /// <param name="key">The key to be added.</param>
        /// <typeparam name="T">The type of the value to be added.</typeparam>
        /// <param name="value">The value to be added.</param>
        /// <returns>Returns a `List/<string/>`</returns>
        [Preserve]
        public List<string> AddParamsToQueryParams<T>(List<string> queryParams, string key, T value)
        {
            if (queryParams == null)
            {
                queryParams = new List<string>();
            }

            key = UnityWebRequest.EscapeURL(key);
            string valueString = UnityWebRequest.EscapeURL(value.ToString());
            queryParams.Add($"{key}={valueString}");
            return queryParams;
        }

        /// <summary>
        /// Constructs a string representing an array path parameter.
        /// </summary>
        /// <param name="pathParam">The list of values to convert to string.</param>
        /// <returns>String representing the param.</returns>
        [Preserve]
        public string GetPathParamString(List<string> pathParam)
        {
            string paramString = "";
            foreach (var value in pathParam)
            {
                paramString += UnityWebRequest.EscapeURL(value) + ",";
            }

            paramString = paramString.Remove(paramString.Length - 1);
            return paramString;
        }

        /// <summary>
        /// Constructs the body of the request based on IO stream.
        /// </summary>
        /// <param name="stream">The IO stream to use.</param>
        /// <returns>Byte array representing the body.</returns>
        public byte[] ConstructBody(System.IO.Stream stream)
        {
            if (stream != null)
            {
                using (System.IO.MemoryStream ms = new System.IO.MemoryStream())
                {
                    stream.CopyTo(ms);
                    return ms.ToArray();
                }
            }

            return null;
        }

        /// <summary>
        /// Construct the request body based on string value.
        /// </summary>
        /// <param name="s">The input body.</param>
        /// <returns>Byte array representing the body.</returns>
        public byte[] ConstructBody(string s)
        {
            return System.Text.Encoding.UTF8.GetBytes(s);
        }

        /// <summary>
        /// Construct request body based on generic object.
        /// </summary>
        /// <param name="o">The object to use.</param>
        /// <returns>Byte array representing the body.</returns>
        public byte[] ConstructBody(object o)
        {
            return JsonSerialization.Serialize(o);
        }

        /// <summary>
        /// Generate an accept header.
        /// </summary>
        /// <param name="accepts">list of accepts objects.</param>
        /// <returns>The generated accept header.</returns>
        public string GenerateAcceptHeader(string[] accepts)
        {
            if (accepts.Length == 0)
            {
                return null;
            }

            for (int i = 0; i < accepts.Length; ++i)
            {
                if (string.Equals(accepts[i], "application/json", System.StringComparison.OrdinalIgnoreCase))
                {
                    return "application/json";
                }
            }

            return string.Join(", ", accepts);
        }

        private static readonly Regex JsonRegex =
            new Regex(@"application\/json(;\s)?((charset=utf8|q=[0-1]\.\d)(\s)?)*");

        /// <summary>
        /// Generate Content Type Header.
        /// </summary>
        /// <param name="contentTypes">The content types.</param>
        /// <returns>The Content Type Header.</returns>
        public string GenerateContentTypeHeader(string[] contentTypes)
        {
            if (contentTypes.Length == 0)
            {
                return null;
            }

            for (int i = 0; i < contentTypes.Length; ++i)
            {
                if (!string.IsNullOrWhiteSpace(contentTypes[i]) && JsonRegex.IsMatch(contentTypes[i]))
                {
                    return contentTypes[i];
                }
            }

            return contentTypes[0];
        }

        /// <summary>
        /// Generate multipart form file section.
        /// </summary>
        /// <param name="paramName">The parameter name.</param>
        /// <param name="stream">The file stream to use.</param>
        /// <param name="contentType">The content type.</param>
        /// <returns>Returns a multipart form section.</returns>
        public IMultipartFormSection GenerateMultipartFormFileSection(string paramName, System.IO.FileStream stream,
            string contentType)
        {
            return new MultipartFormFileSection(paramName, ConstructBody(stream), GetFileName(stream.Name),
                contentType);
        }

        /// <summary>
        /// Generate multipart form file section.
        /// </summary>
        /// <param name="paramName">The parameter name.</param>
        /// <param name="stream">The IO stream to use.</param>
        /// <param name="contentType">The content type.</param>
        /// <returns>Returns a multipart form section.</returns>
        public IMultipartFormSection GenerateMultipartFormFileSection(string paramName, System.IO.Stream stream,
            string contentType)
        {
            return new MultipartFormFileSection(paramName, ConstructBody(stream), Guid.NewGuid().ToString(),
                contentType);
        }

        private string GetFileName(string filePath)
        {
            return System.IO.Path.GetFileName(filePath);
        }
    }

    /// <summary>
    /// DeleteItemRequest
    /// Delete Player Item
    /// </summary>
    [Preserve]
    internal class DeleteItemRequest : DataApiBaseRequest
    {
        /// <summary>Accessor for key </summary>
        [Preserve]
        public string Key { get; }

        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public string ProjectId { get; }

        /// <summary>Accessor for playerId </summary>
        [Preserve]
        public string PlayerId { get; }

        /// <summary>Accessor for writeLock </summary>
        [Preserve]
        public string WriteLock { get; }

        string PathAndQueryParams;

        /// <summary>
        /// DeleteItem Request Object.
        /// Delete Player Item
        /// </summary>
        /// <param name="key">Item key.</param>
        /// <param name="projectId">ID of the project.</param>
        /// <param name="playerId">The player ID supplied by the Authorization service.</param>
        /// <param name="writeLock">Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.</param>
        [Preserve]
        public DeleteItemRequest(string key, string projectId, string playerId, string writeLock = default(string))
        {
            Key = key;

            ProjectId = projectId;

            PlayerId = playerId;

            WriteLock = writeLock;
            PathAndQueryParams = $"/v1/data/projects/{projectId}/players/{playerId}/items/{key}";

            List<string> queryParams = new List<string>();

            if (!string.IsNullOrEmpty(WriteLock))
            {
                queryParams = AddParamsToQueryParams(queryParams, "writeLock", WriteLock);
            }

            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if (!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = { };

            string[] accepts = { "application/problem+json" };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }

            var httpMethod = "DELETE";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }

    /// <summary>
    /// DeleteItemsRequest
    /// Delete Player Items
    /// </summary>
    [Preserve]
    internal class DeleteItemsRequest : DataApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public string ProjectId { get; }

        /// <summary>Accessor for playerId </summary>
        [Preserve]
        public string PlayerId { get; }

        string PathAndQueryParams;

        /// <summary>
        /// DeleteItems Request Object.
        /// Delete Player Items
        /// </summary>
        /// <param name="projectId">ID of the project.</param>
        /// <param name="playerId">The player ID supplied by the Authorization service.</param>
        [Preserve]
        public DeleteItemsRequest(string projectId, string playerId)
        {
            ProjectId = projectId;

            PlayerId = playerId;

            PathAndQueryParams = $"/v1/data/projects/{projectId}/players/{playerId}/items";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if (!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = { };

            string[] accepts = { "application/problem+json" };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }

            var httpMethod = "DELETE";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }

    /// <summary>
    /// GetItemsRequest
    /// Get Player Items
    /// </summary>
    [Preserve]
    internal class GetItemsRequest : DataApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public string ProjectId { get; }

        /// <summary>Accessor for playerId </summary>
        [Preserve]
        public string PlayerId { get; }

        /// <summary>Accessor for keys </summary>
        [Preserve]
        public List<string> Keys { get; }

        /// <summary>Accessor for after </summary>
        [Preserve]
        public string After { get; }

        string PathAndQueryParams;

        /// <summary>
        /// GetItems Request Object.
        /// Get Player Items
        /// </summary>
        /// <param name="projectId">ID of the project.</param>
        /// <param name="playerId">The player ID supplied by the Authorization service.</param>
        /// <param name="keys">The keys to retrieve, in exploded form style, e.g. `keys=KEY1&keys=KEY2&keys=KEY3`.</param>
        /// <param name="after">The key after which to retrieve the next page of keys.</param>
        [Preserve]
        public GetItemsRequest(string projectId, string playerId, List<string> keys = default(List<string>),
            string after = default(string))
        {
            ProjectId = projectId;

            PlayerId = playerId;

            Keys = keys;
            After = after;
            PathAndQueryParams = $"/v1/data/projects/{projectId}/players/{playerId}/items";

            List<string> queryParams = new List<string>();

            if (Keys != null)
            {
                var keysStringValues = Keys.Select(v => v.ToString()).ToList();
                queryParams = AddParamsToQueryParams(queryParams, "keys", keysStringValues, "form", true);
            }

            if (!string.IsNullOrEmpty(After))
            {
                queryParams = AddParamsToQueryParams(queryParams, "after", After);
            }

            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if (!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = { };

            string[] accepts = { "application/json", "application/problem+json" };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }

            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }

    /// <summary>
    /// GetKeysRequest
    /// Get Player Keys
    /// </summary>
    [Preserve]
    internal class GetKeysRequest : DataApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public string ProjectId { get; }

        /// <summary>Accessor for playerId </summary>
        [Preserve]
        public string PlayerId { get; }

        /// <summary>Accessor for after </summary>
        [Preserve]
        public string After { get; }

        string PathAndQueryParams;

        /// <summary>
        /// GetKeys Request Object.
        /// Get Player Keys
        /// </summary>
        /// <param name="projectId">ID of the project.</param>
        /// <param name="playerId">The player ID supplied by the Authorization service.</param>
        /// <param name="after">Returns the page of results after the key specified.</param>
        [Preserve]
        public GetKeysRequest(string projectId, string playerId, string after = default(string))
        {
            ProjectId = projectId;

            PlayerId = playerId;

            After = after;
            PathAndQueryParams = $"/v1/data/projects/{projectId}/players/{playerId}/keys";

            List<string> queryParams = new List<string>();

            if (!string.IsNullOrEmpty(After))
            {
                queryParams = AddParamsToQueryParams(queryParams, "after", After);
            }

            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if (!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = { };

            string[] accepts = { "application/json", "application/problem+json" };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }

            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }

    /// <summary>
    /// SetItemRequest
    /// Set Player Item
    /// </summary>
    [Preserve]
    internal class SetItemRequest : DataApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public string ProjectId { get; }

        /// <summary>Accessor for playerId </summary>
        [Preserve]
        public string PlayerId { get; }

        /// <summary>Accessor for setItemBody </summary>
        [Preserve]
        public Unity.Services.CloudSave.Internal.Models.SetItemBody SetItemBody { get; }

        string PathAndQueryParams;

        /// <summary>
        /// SetItem Request Object.
        /// Set Player Item
        /// </summary>
        /// <param name="projectId">ID of the project.</param>
        /// <param name="playerId">The player ID supplied by the Authorization service.</param>
        /// <param name="setItemBody">Add a data item to store for a player.</param>
        [Preserve]
        public SetItemRequest(string projectId, string playerId,
            Unity.Services.CloudSave.Internal.Models.SetItemBody setItemBody =
                default(Unity.Services.CloudSave.Internal.Models.SetItemBody))
        {
            ProjectId = projectId;

            PlayerId = playerId;

            SetItemBody = setItemBody;
            PathAndQueryParams = $"/v1/data/projects/{projectId}/players/{playerId}/items";

            List<string> queryParams = new List<string>();

            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            if (SetItemBody != null)
            {
                return ConstructBody(SetItemBody);
            }

            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if (!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = { "application/json" };

            string[] accepts = { "application/json", "application/problem+json" };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }

            var httpMethod = "POST";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }

    /// <summary>
    /// SetItemBatchRequest
    /// Set Player Item Batch
    /// </summary>
    [Preserve]
    internal class SetItemBatchRequest : DataApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public string ProjectId { get; }

        /// <summary>Accessor for playerId </summary>
        [Preserve]
        public string PlayerId { get; }

        /// <summary>Accessor for setItemBatchBody </summary>
        [Preserve]
        public Unity.Services.CloudSave.Internal.Models.SetItemBatchBody SetItemBatchBody { get; }

        string PathAndQueryParams;

        /// <summary>
        /// SetItemBatch Request Object.
        /// Set Player Item Batch
        /// </summary>
        /// <param name="projectId">ID of the project.</param>
        /// <param name="playerId">The player ID supplied by the Authorization service.</param>
        /// <param name="setItemBatchBody">Set batch data items for a player.</param>
        [Preserve]
        public SetItemBatchRequest(string projectId, string playerId,
            Unity.Services.CloudSave.Internal.Models.SetItemBatchBody setItemBatchBody =
                default(Unity.Services.CloudSave.Internal.Models.SetItemBatchBody))
        {
            ProjectId = projectId;

            PlayerId = playerId;

            SetItemBatchBody = setItemBatchBody;
            PathAndQueryParams = $"/v1/data/projects/{projectId}/players/{playerId}/item-batch";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            if (SetItemBatchBody != null)
            {
                return ConstructBody(SetItemBatchBody);
            }

            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if (!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = { "application/json" };

            string[] accepts = { "application/json", "application/problem+json" };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }

            var httpMethod = "POST";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }

    /// <summary>
    /// GetCustomItemsRequest
    /// Get Custom Items
    /// </summary>
    [Preserve]
    internal class GetCustomItemsRequest : DataApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public string ProjectId { get; }

        /// <summary>Accessor for customId </summary>
        [Preserve]
        public string CustomId { get; }

        /// <summary>Accessor for keys </summary>
        [Preserve]
        public List<string> Keys { get; }

        /// <summary>Accessor for after </summary>
        [Preserve]
        public string After { get; }

        string PathAndQueryParams;

        /// <summary>
        /// GetCustomItems Request Object.
        /// Get Custom Items
        /// </summary>
        /// <param name="projectId">ID of the project.</param>
        /// <param name="customId">The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.</param>
        /// <param name="keys">The keys to retrieve, in exploded form style, e.g. `keys=KEY1&keys=KEY2&keys=KEY3`.</param>
        /// <param name="after">The key after which to retrieve the next page of keys.</param>
        [Preserve]
        public GetCustomItemsRequest(string projectId, string customId, List<string> keys = default(List<string>),
            string after = default(string))
        {
            ProjectId = projectId;

            CustomId = customId;

            Keys = keys;
            After = after;
            PathAndQueryParams = $"/v1/data/projects/{projectId}/custom/{customId}/items";

            List<string> queryParams = new List<string>();

            if (Keys != null)
            {
                var keysStringValues = Keys.Select(v => v.ToString()).ToList();
                queryParams = AddParamsToQueryParams(queryParams, "keys", keysStringValues, "form", true);
            }

            if (!string.IsNullOrEmpty(After))
            {
                queryParams = AddParamsToQueryParams(queryParams, "after", After);
            }

            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if (!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = { };

            string[] accepts = { "application/json", "application/problem+json" };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }

            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }

    /// <summary>
    /// GetCustomKeysRequest
    /// Get Custom Keys
    /// </summary>
    [Preserve]
    internal class GetCustomKeysRequest : DataApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public string ProjectId { get; }

        /// <summary>Accessor for customId </summary>
        [Preserve]
        public string CustomId { get; }

        /// <summary>Accessor for after </summary>
        [Preserve]
        public string After { get; }

        string PathAndQueryParams;

        /// <summary>
        /// GetCustomKeys Request Object.
        /// Get Custom Keys
        /// </summary>
        /// <param name="projectId">ID of the project.</param>
        /// <param name="customId">The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.</param>
        /// <param name="after">Returns the page of results after the key specified.</param>
        [Preserve]
        public GetCustomKeysRequest(string projectId, string customId, string after = default(string))
        {
            ProjectId = projectId;

            CustomId = customId;

            After = after;
            PathAndQueryParams = $"/v1/data/projects/{projectId}/custom/{customId}/keys";

            List<string> queryParams = new List<string>();

            if (!string.IsNullOrEmpty(After))
            {
                queryParams = AddParamsToQueryParams(queryParams, "after", After);
            }

            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if (!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = { };

            string[] accepts = { "application/json", "application/problem+json" };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }

            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
}
